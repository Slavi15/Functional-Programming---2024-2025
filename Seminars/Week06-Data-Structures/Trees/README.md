## Двоични дървета

```racket
(define (make-tree tr left right) (list tr left right))
(define mk make-tree)

(define (make-leaf tr) (list tr '() '()))
(define (leaf? tr) (and (not (null? tr)) (not (empty-t? (left-t tr))) (not (empty-t? (right-t tr))))))

(define (root tr) (car tr))
(define (left-t tr) (cadr tr))
(define (right-t tr) (caddr tr))

(define (empty-t? tr) (null? tr))

(define t (make-tree 5
                     (make-tree 1
                                (make-tree 4
                                           '()
                                           (make-leaf 13))
                                (make-leaf 3))
                     (make-tree 8
                                (make-tree 0
                                           (make-leaf 10)
                                           (make-leaf 9))
                                (make-leaf 11))))

(define bst (make-tree 3
                       (make-tree 1
                                  '()
                                  (make-leaf 2))
                       (make-tree 4
                                  '()
                                  (make-leaf 5))))
```

1. Абстракция: `(make-tree root left right)`, `(root-tree tree)`, `(left-tree tree)`,
   `(right-tree tree)`, `(empty-tree? tree)`, `(leaf-tree? tree)`, `(tree? x)`

2. Напишете функции `(collect-pre-order t)`, `(collect-in-order t)` и `(collect-post-order t)`, които връща списък от елементите на дървото, обходено съотвено `корен-ляво-дясно`, `ляво-корен-дясно` и `ляво-дясно-корен`.

3. Напишете функция `(map-tree f t)`, която заменя всеки връх `x` от дървото `t` с `(f x)`.

```racket
(map-tree (lambda (x) (* x x)) dl) ; -> '((1 4) ((9 (16) 25) (((36)))) (49))
```

4. Напишете функция `(height t)`, която намира височината на дървото `t`. Това е броят на върховете в най-дългия път.

5. (**БОНУС** 0.5 т.) Напишете функция `(level n t)`, която връща списък с всички върхове от дървото с дълбочина `n`.
> Дълбочината на един връх `x` от дърво е броят ребра, които го свързват с корена `r`. Това е равно и на броя върхове от `r` до `x`, без да броим `x`. Дълбочината на корена е 0.

6. Напишете функция `(count-leaves t)`, която връща броя листа на t.
> Листо е връх от дърво, който няма наследници.

7. Напишете функция `(remove-leaves t)`, която връща дървото t, премахвайки листата му.

8. (**БОНУС** 0.5 т.) Напишете функция `(invert t)`, която разменя левите поддървета на `t` с десните.

9. (**БОНУС** 0.5 т.) Напишете функция `(bst? t)`, която намира дали `t` е двоично **наредено** дърво.

10. (**БОНУС** 0.5 т.) Напишете функция `(insert-bst x t)`, която добавя елемент `x` в двоично **наредено** дърво `t`, запазвайки наредбата му.
> Така може да направите функция `(list->bst l)`, която по списък прави наредено дърво, и чрез някоя от `collect` функциите от задачa 1 може да реализирате сортиране на списък.

11. (**БОНУС** 0.5 т.) Двоично дърво е балансирано, ако:
   1. е празното двоично дърво или
   2. височините на лявото и дясното поддърво се различават най-много с 1 и лявото и дясното поддървета са балансирани.

   Напишете предикат `(balanced? tree)`, който проверява дали дървото `tree` е балансирано.

---

## Задача 00 - Брой атоми
Напишете функция `count-atoms`, която намира броя на атомите в дълбок списък.

## Задача 01 - Foldr за дълбоки списъци
Напишете функциите `deep-foldr`, който е еквивалентът на `foldr` за дълбоки списъци, с разликата, че приема и функция `term`, която се прилага над всеки от атомите.

### Пример:
```scheme
(deep-foldr + (lambda (x) x) 0 dl) ; -> 28
```

## Задача 02 - Map и Filter за дълбоки списъци
Напишете функциите `deep-map` и `deep-filter`, които са еквивалентите на `map` и `filter` за дълбоки списъци.

### Пример:
```scheme
(deep-map (lambda (x) (* x x)) dl) ; -> '((1 4) ((9 (16) 25) (((36)))) (49))
(deep-filter even? dl) ; -> '((2) (((4)) (((6)))))
```

## Задача 03 - Търсене в дълбок списък
Напишете функция `deep-member?`, която проверява дали елемент се съдържа в дълбок списък.

### Пример:
```scheme
(deep-member? 5 dl) ; -> #t
(deep-member? 10 dl) ; -> #f
```

## Задача 04 - Изглаждане на дълбок списък
Напишете функция `flatten`, която по подаден дълбок списък, връща списък от атомите в дълбокия списък.

### Пример:
```scheme
(flatten dl) ; -> '(1 2 3 4 5 6 7)
```

## Задача 05 - Височина на дърво
Напишете функция, която намира височина на двоично дърво.

### Пример:
```scheme
(height t) ; -> 4
```

## Задача 06 - Брой листа
Напишете функция, която намира броя на листата на двоично дърво.

### Пример:
```scheme
(count-leafs t) ; -> 5
```

## Задача 07 - Map за дървета
Напишете функция `map-tree`, която е еквивалентът на `map` за двоични дървета.

### Пример:
```scheme
(map-tree (lambda (x) (* x x)) t) ; -> '(25
                                         (1 (16 () (169 () ())) (9 () ()))
                                         (64 (0 (100 () ()) (81 () ())) (121 () ())))
```

## Задача 08 - Обхождане на дърво
Напишете функция, която обхожда двоично дърво по стратегията "ляво-корен-дясно", и връща списък от елементите на дървото в реда, в който са били посетени.

### Пример:
```scheme
(tree-to-list t) ; -> '(4 13 1 3 5 10 0 9 8 11)
```

## Задача 09 - Ниво на дърво
Напишете функция, която връща списък от елементите на двоично дърво, които са на едно и също ниво. Приемаме, че първото ниво е 0.

### Пример:
```scheme
(level 2 t) ; -> '(4 3 0 11)
```

## Задача 10 - Път до елемент
Напишете функция, която търси елемент в двоично дърво. Ако елементът бива намерен, функцията да връща пътя до елемента като списък от елементите, през които минава. В противен случай функцията да връща `#f`.

### Пример:
```scheme
(path-to 10 t) ; -> '(5 8 0 10)
```

## Задача 11 - Подрязване
Напишете функция, която премахва всички листа в двоично дърво.

### Пример:
```scheme
(prune t) ; -> '(5 (1 (4 () ()) ()) (8 (0 () ()) ()))
```

## Задача 12 - Двоично наредено дърво
Напишете функция, която проверява дали подаденото двоично дърво е наредено.

### Пример:
```scheme
(bst? t) ; -> #f
(bst? bst) ; -> #t
```

## Задача 13 - Вмъкване в двоично наредено дърво
Напишете функция, която вмъква елемент в двоично наредено дърво.

### Пример:
```scheme
(bst-insert 7 bst) ; -> '(3 (1 () (2 () ())) (4 () (5 () (7 () ()))))
```

## Задача 14 - Tree Sort
Напишете функция, която сортира списък чрез двоично наредено дърво.

### Пример:
```scheme
(tree-sort '(5 1 4 6 3 7)) ; -> '(1 3 4 5 6 7)
```

---

## Задача 00 - От предния път
Довършете задачите за дървета от предния път.

## Задача 01 - Дърво на извод
Напишете функция, която приема дърво, чиито листа са числа, а останалите възли - аритметични операции. Функцията да пресмята какъв би бил резултата от прилагането на операциите над техните поддървета.

### Пример:
```scheme
(define derivation-tree (make-tree +
                                   (make-tree -
                                              (make-tree +
                                                         (make-leaf 5)
                                                         (make-leaf 7))
                                              (make-leaf 3))
                                   (make-tree *
                                              (make-tree +
                                                         (make-tree /
                                                                    (make-leaf 20)
                                                                    (make-leaf 4))
                                                         (make-leaf 9))
                                              (make-leaf 6))))

(calculate derivation-tree) ; -> 93
```

## Задача 02 - Обръщане на BST
Напишете функция, която сменя знаците на числата във възлите на двоично наредено дърво, като отново запазва наредеността.

### Пример:
```scheme
(inverse bst) ; -> '(-3 (-4 (-5 () ()) ()) (-1 (-2 () ()) ()))
```

## Задача 03 - Огледално дърво
Напишете функция, която проверява дали двоично дърво е огледално. Огледално дърво наричаме такова дърво, на което дясното поддърво има обратно симетрична структура спрямо лявото.

### Пример:
```scheme
;        4
;       / \         
;      1   6
;     /\   /\     
;    7  2 0  8
;    \      / 
;     10   11 

(define mirror (make-tree 4
                          (make-tree 1
                                     (make-tree 7
                                                '()
                                                (make-leaf 10))
                                     (make-leaf 2))
                          (make-tree 6
                                     (make-leaf 0)
                                     (make-tree 8
                                                (make-leaf 11)
                                                '()))))

(mirror? mirror) ; -> #t
(mirror? t) ; -> #f
```

## Задача 04 - Премахване на елемент в BST
Напишете функция, която по подаден елемент и двоично наредено дърво, премахва елемента от дървото, като след това дървото трябва да остане наредено. Ако елементът не е част от дървото, да се върне същото дърво.

### Пример:
```scheme
(bst-remove 3 bst) ; -> '(4 (1 () (2 () ())) (5 () ()))
```
