# Още списъци.

### Задача 1
Реализирайте процедурата `(insert-at x position xs)` от миналата седмица, използвайки `take` и `drop`.

```racket
(equal? (insert-at 0 1 '(10 20 30)) '(0 10 20 30))
(equal? (insert-at 0 2 '(10 20 30)) '(10 0 20 30))
(equal? (insert-at 0 3 '(10 20 30)) '(10 20 0 30))
(equal? (insert-at 0 4 '(10 20 30)) '(10 20 30 0))
(equal? (insert-at 0 1 '()) '(0))
```

### Задача 2
Реализирайте процедура `(get-sublist start-idx end-idx xs)`, която връща подсписък на `xs`, съдържащ елементите на индекси от `start-idx` и `end-idx`.

```racket
(equal? (get-sublist 2 6 '(1 2 2 3 1 5 6 7 7)) '(2 3 1 5 6))
```

### Задача 3
Реализирайте процедура `count-occurrences`, която брои колко пъти даден списък се съдържа в друг списък.

```racket
(= (count-occurrences '(1 5) '(1 5 2 3 1 5 6 7 7 1 5)) 3)
(= (count-occurrences '(5 5) '(5 5 5 3 1 5 6 7 5 5 5)) 4)
(= (count-occurrences '(6 6) '(2 2)) 0)
```

### Задача 4
Реализирайте процедура `ordered?`, която приема списък `xs` и връща ламбда, приемаща бинарен предикат `pred?` и проверява дали списъкът е сортиран според `pred?`.

```racket
(equal? ((ordered? '(1 2 3 5)) (λ (x y) (< x y))) #t)
(equal? ((ordered? '(1 8 29 92)) (λ (x y) (= y (+ (* x 3) 5)))) #t)
(equal? ((ordered? '(1 8 3 14)) (λ (x y) (= y (+ (* x 3) 5)))) #f)
```

### Задача 5
Реализирайте процедура `where`, която приема списък от числа и списък от унарни предикати и връща елементите на списъка, които удовлетворяват всички предикати.

```racket
(equal? (where '(3 4 5 6 7 8 9 10) (list even? (lambda (x) (> x 5)))) '(6 8 10))
(equal? (where '(3 4 5 7) (list even? (lambda (x) (> x 5)))) '())
(equal? (where '() (list odd? (λ (x) (> x 3)) (λ (x) (< x 20)))) '())
(equal? (where '(1 2 3 4 5 6 7 8 9 10 11 13 15) (list odd? (λ (x) (> x 3)) (λ (x) (< x 20)))) '(5 7 9 11 13 15))
```

### Задача 6
Реализирайте процедура `my-cartesian-product`, която приема две множества (списъци без повторения) и връща тяхното Декартово произведение.

> Забележка: Не използвайте вградената процедура `cartesian-product`

```racket
(equal? (my-cartesian-product '(1 2) '(3 4)) '((1 . 3) (1 . 4) (2 . 3) (2 . 4)))
(equal? (my-cartesian-product '(1 2 3 4 5) '(6 7 8)) '((1 . 6) (1 . 7) (1 . 8) (2 . 6) (2 . 7) (2 . 8) (3 . 6) (3 . 7) (3 . 8) (4 . 6) (4 . 7) (4 . 8) (5 . 6) (5 . 7) (5 . 8)))
```

### Задача 7
Дефинирайте процедура `my-flatten`, която приема списък от вложени списъци и връща списък само на едно ниво, съдържащ всички елементи на всички списъци.

```racket
(equal? (my-flatten '((1 2 3) (4 5 6) ((7 8) (9 10 (11 (12)))))) '(1 2 3 4 5 6 7 8 9 10 11 12))
```

### Задача 8
Дефинирайте процедура `shuffle`, която получава списък от `2*n` елемента във вида `x1 x2 ... xn y1 y2 ... yn` и връща списък от вида `x1 y1 x2 y2 ... xn yn`.

```racket
(equal? (shuffle '(2 5 1 3 4 7)) '(2 3 5 4 1 7))
(equal? (shuffle '(1 2 3 4 4 3 2 1)) '(1 4 2 3 3 2 4 1))
(equal? (shuffle '(1 1 2 2)) '(1 2 1 2))
```

### Задача 9
Дефинирайте процедура `tabulate`, която приема унарна процедура `f` и връща бинарна процедура на числата `a`и `b`. Резултатът от извикването `((tabulate f) a b)` трябва да бъде списък от точкови двойки във вида `(i . f(i))`, където `i` е в интервала `[a;b]`.

```racket
(equal? ((tabulate (λ (x) (* x x))) 1 5) '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25)))
```

### Задача 10
Дефинирайте процедура `deep-delete`, която премахва всички атоми, които са по-малки от тяхната дълбочина.

> Забележка: Дълбочина на един атом `x`в списък `xs` == колко пъти трябва да приложим `car` върху `xs`, за да достигнем `x`

```racket
(equal? (deep-delete '(1 (2 (2 4) 1) 0 (3 (1)))) '(1 (2 (4)) (3 ())))
```