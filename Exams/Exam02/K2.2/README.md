## Второ контролно по ФП 2024-2025

**Задача 1: (9 т.)** Да се реализира функция `outsideHyp`, която приема три цели числа **a**, **b** и **c** и връща безкраен поток, без повторения, от наредени двойки от цели числа `(x, y)`, за които е изпълнено: `(x - a) * (y - b) > c`

**Пример:**

```haskell
outsideHyp 1 1 4 -- => [ (4, 3), (-3, -2), (3, 4), (-2, -3), (6, 2), (-5, -1), ... ]
```

**Задача 2: (8 т.)** Да се реализира функция `deepFilterMap`, която приема дълбок списък **xss**, двуместна функция **f**, и два двуместни предиката **p** и **q**. Функцията да връща трансформирано копие на **xss**, в което са изтрити всички атоми, които удовлетворяват **p**, а **f** е приложена върху тези от останалите атоми, които удовлетворяват **q**. Като аргументи на **f**, **p** и **q** се подават атомът и неговата дълбочина в списъка. Дълбочината на елемент **x** в дълбок списък дефинираме рекурсивно като `1+` дълбочината на списъка, на който **x** е непосредствен елемент, като приемаме, че целият дълбок списък е на дълбочина 0.

**Пример:**

```racket
(deepFilterMap '(1 (2 (5 3) 3) 0) * > =) ;; => (1 (4 (9)) 0)
```

**Задача 3:** Всеки кръг от шампионата "Formula One" е представен като двойка от името на пистата (символен низ) и списък от пилоти.
Всеки пилот е представен с име (символен низ), спечелени точки от състезанието, наказателни секунди и време за най-бърза обиколка в секунди.
Данните за сезона се представят като списък от кръгове и се подават като параметър на всяка от функциите по-долу.

```haskell
type Pilot = (String, Integer, Integer, Integer)
```

```haskell
type Round = (String, [Pilot])
```

```haskell
type Tournament = [Round]
```

**А) (4 т.)** Да се реализира функция `allLosers`, която връща списък без повторения от имената на всички пилоти, които не са били първи в нито един кръг;

**Б) (4 т.)** Да се реализира функция `slowestFastest`, която връща списък от двойки `(пилот, най-голямо време за най-бърза обиколка от всички кръгове)`, сортиран във възходящ ред по втория компонент;

**В) (5 т.)** Да се реализира функция `leastPenalty`, която връща името на пилота, който е получил най-малко общо секунди наказания през сезона. Ако има повече от един такъв, функцията може да върне, който и да е от тях;

**Г) (5 т.)** Да се реализира функция `winFastestLaps`, която връща списък от имената на всички писти, на които пилотът, направил най-бързата обиколка, също е и победител в съответния кръг. Победител е пилотът с най-много точки от този кръг, като по правилата на "Formula One" има единствен такъв;

**Пример:**

```haskell
season :: Tournament
season = [
	("Silverstone", [
		("LeClerc", 15, 10, 82), 
		("Hamilton", 25, 5, 80), 
		("Verstappen", 18, 15, 77)
	]),
    	("Monza", [
		("Sainz", 18, 5, 81), 
		("Hamilton", 15, 10, 79), 
		("Verstappen", 25, 5, 76)
	]),
	("Spa", [
		("Norris", 18, 0, 78), 
		("Russell", 25, 5, 76)
	])
]
```

```haskell
allLosers :: Tournament -> [String]
allLosers season -- => ["LeClerc", "Sainz", "Norris"]
```

```haskell
slowestFastest :: Tournament -> [(String, Integer)]
slowestFastest season -- => [("Russell", 76), ("Verstappen", 77), ("Norris", 78), ("Hamilton", 80), ("Sainz", 81), ("LeClerc", 82)]
```

```haskell
leastPenalty :: Tournament -> String
leastPenalty season -- => "Norris"
```

```haskell
winFastestLaps :: Tournament -> [String]
winFastestLaps season -- => ["Monza", "Spa"]
```

**Забележка:** *Използването на всички стандартни функции в R5RS: както и на функциите `accumulate`, `accumulate-i`, `filter`, `foldr`, `foldl`, `foldr1`, `foldl1` е позволено, но не е задължително*
