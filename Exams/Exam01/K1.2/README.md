## Първо контролно по ФП 2024-2025

**Задача 1: (10 т.)** Да се дефинира функция `(sum-with-position n)`, която приема неотрицателно число **n** и връща ново число, което се получава, като всяка цифра **d** на **n** се замести с числото, което се получава, като **d** се събере с номера на позицията си. Позициите се броят отдясно наляво, като цифрата на единиците е на позиция 1.

**Примери:**

```racket
(sum-with-position 123) ;; => 444 => 1 + 3; 2 + 2; 3 + 1
(sum-with-position 507) ;; => 828 => 5 + 3; 0 + 2; 7 + 1
(sum-with-position 987) ;; => 12108 => 9 + 3; 8 + 2; 7 + 1
(sum-with-position 1249) ;; => 55610 => 1 + 4; 2 + 3; 4 + 2; 9 + 1
(sum-with-position 9000) ;; => 13321 => 9 + 4; 0 + 3; 0 + 2; 0 + 1
(sum-with-position 0) ;; => 1
```

**Задача 2: (10 т.)** Да се дефинира функция `(maxmin fm l)`, която по дадена непразна матрица от едноместни числови функции **fm** и непразен списък от числа **1**. намира за всеки ред в матрицата минималното число, което може да се получи след прилагане на някоя функция в реда над някой елемент на списька 1, и връща най-голямото такова минимално число. Матрицата се представя като списък от редовете си.

**Бонус: (5 т.)** Решете задачата без рекурсия, само с функции от по-висок ред

**Примери:**

```racket
(maxmin (list (list square exp) (list cos 1+)) '(-1 0 1)) ;; => 0.0
(maxmin (list (list square log) (list sin 1-)) '(2 3 4)) ;; => 0.6931471805599453
(maxmin (list (list abs exp)) '(0 -2 5)) ;; => 0
(maxmin (list (list (lambda (x) (* x x)) (lambda (x) (+ x 1)))) '(2 3 4)) ;; => 3
(maxmin (list (list abs exp)) '(1 2 3)) ;; => 1
(maxmin (list (list square log)) '(1 2 3)) ;; => 0
(maxmin (list (list (lambda (x) (* x x)) (lambda (x) (+ x 2)))) '(1 2 3)) ;; => 1
(maxmin (list (list cos sin) (list (lambda (x) (- x 1)) (lambda (x) (/ x 2)))) '(0 1 2)) ;; => -0.4161468365471424
```

**Задача 3: (10 т.)** Да се дефинира функция `(minimum-odd-nodes-prod bt)`, която приема непразно двоично дърво от цели числа и връща път от корена, в който произведението на нечетните елементи е минимално. Ако има няколко такива пътя, да се върне такъв с максимална дължина.

**Примери:**

```racket
(minimum-odd-nodes-prod '(1 (3 () ()) (-3 (4 () ()) (-1 () ())))) ;; => (1 -3 4)
(minimum-odd-nodes-prod '(1 (3 () ()) (-3 (-5 () ()) (-1 () ())))) ;; => (1 -3)
```

**Забележка:** *Използването на всички стандартни функции в R5RS: както и на функциите `accumulate`, `accumulate-i`, `filter`, `foldr`, `foldl`, `foldr1`, `foldl1` е позволено, но не е задължително*
