{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedRecordDot #-}

module Matrix where

data Three = Zero | One | Two
  deriving (Eq, Show)

flipThree :: Three -> Three
flipThree Zero = Two
flipThree One = One
flipThree Two = Zero

threeToInteger :: Three -> Integer
threeToInteger Zero = 0
threeToInteger One = 1
threeToInteger Two = 2

type Thrice a = Three -> a

thriceToTriple :: Thrice a -> (a, a, a)
thriceToTriple t = (t Zero, t One, t Two)

thrice :: a -> a -> a -> Thrice a
thrice x y z t =
  case t of
    Zero -> x
    One -> y
    Two -> z

-- | Note that there are two ways to access this field:
-- either with the
-- @get :: Matrix a -> Thrice (Thrice a)@
-- function which is autogenerated (not recommended)
-- or by using record dot syntax:
-- @matget rix :: Thrice (Thrice a)@
-- The latter requires the @OverloadedRecordDot@ language extension,
-- which is enabled at the top of this file.

newtype Matrix a = MkMatrix {get :: Thrice (Thrice a)}

-- | MkMatrix $ \case
--   ...cases...
-- is exactly the same as
-- MkMatrix $ \i ->
--   case i of
--     ...cases...
-- It requires the `LambdaCase` language extension - it's enabled at the top of the file

matrix ::
  a -> a -> a ->
  a -> a -> a ->
  a -> a -> a ->
  Matrix a
matrix x0 x1 x2 y0 y1 y2 z0 z1 z2 =
  MkMatrix $
    thrice
      (thrice x0 x1 x2)
      (thrice y0 y1 y2)
      (thrice z0 z1 z2)

constantMatrix :: a -> Matrix a
constantMatrix x = MkMatrix $ \_ _ -> x

diagonalMatrix :: a -> Matrix (Maybe a)
diagonalMatrix x =
  MkMatrix $ \i j -> if (i == j) then Just x else Nothing

otherDiagonalMatrix :: a -> Matrix (Maybe a)
otherDiagonalMatrix x =
  MkMatrix $ \i j -> if (i == flipThree j) then Just x else Nothing

addMatrix :: Matrix Integer -> Matrix Integer -> Matrix Integer
addMatrix (MkMatrix xss) (MkMatrix yss) =
  MkMatrix $ \i j -> (xss i j) + (yss i j)

showMatrix :: (a -> String) -> Matrix a -> String
showMatrix f (MkMatrix xss) =
  let rowPrinting row = f (row Zero) ++ " " ++ f (row One) ++ " " ++ f (row Two)
      rows = [ rowPrinting (xss Zero), rowPrinting (xss One), rowPrinting (xss Two) ]
  in unlines rows

ix :: Three -> Three -> Matrix a -> a
ix x y (MkMatrix xss) = (xss x y)

getRow :: Three -> Matrix a -> Thrice a
getRow idx (MkMatrix xss) = (xss idx)

getCol :: Three -> Matrix a -> Thrice a
getCol idx (MkMatrix xss) = \i -> (xss i idx)

getDiag :: Matrix a -> Thrice a
getDiag (MkMatrix xss) = \i -> (xss i i)

getOtherDiag :: Matrix a -> Thrice a
getOtherDiag (MkMatrix xss) = \i -> (xss i (flipThree i))

transpose :: Matrix a -> Matrix a
transpose (MkMatrix xss) =
  MkMatrix $ \i j -> (xss j i)

foldThriceWith :: (a -> a -> a) -> Thrice a -> a
foldThriceWith f thr =
  let first = (thr Zero)
      second = (thr One)
      third = (thr Two)
  in foldl f first [ second, third ]

-- foldThriceWith f thr = (thr Zero) `f` (thr One) `f` (thr Two)

foldMatrixWith :: (a -> a -> a) -> Matrix a -> a
foldMatrixWith f (MkMatrix xss) =
  let first = (foldThriceWith f (xss Zero))
      second = (foldThriceWith f (xss One))
      third = (foldThriceWith f (xss Two))
  in foldl f first [ second, third ]

-- foldMatrixWith f (MkMatrix mtx) = (foldThriceWith f (mtx Zero)) `f` (foldThriceWith f (mtx One)) `f` (foldThriceWith f (mtx Two))
-- first `f` second `f` third

eqRow :: (a -> a -> Bool) -> Thrice a -> Thrice a -> Bool
eqRow f xs ys =
  all (\i -> f (xs i) (ys i)) [ Zero, One, Two ]

eqMatrix :: (a -> a -> Bool) -> Matrix a -> Matrix a -> Bool
eqMatrix f (MkMatrix xss) (MkMatrix yss) =
  all (\i -> eqRow f (xss i) (yss i)) [ Zero, One, Two ]

imapThrice :: (Three -> a -> b) -> Thrice a -> Thrice b
imapThrice f thr = \i -> f i (thr i)

mapThrice :: (a -> b) -> Thrice a -> Thrice b
mapThrice f thr = \i -> f (thr i)

imapMatrix :: (Three -> Three -> a -> b) -> Matrix a -> Matrix b
imapMatrix f (MkMatrix xss) =
  MkMatrix $ \i j -> f i j (xss i j)

mapMatrix :: (a -> b) -> Matrix a -> Matrix b
mapMatrix f (MkMatrix xss) =
  MkMatrix $ \i j -> f (xss i j)

place :: Three -> Three -> a -> Matrix a -> Matrix a
place i j x (MkMatrix xss) =
  MkMatrix $ imapThrice (\rowIndex row ->
    if rowIndex == i
      then imapThrice (\colIndex val -> if colIndex == j then x else val) row
      else row) xss

concatThriceWith :: String -> Thrice String -> String
concatThriceWith str thr =
  foldl (\x acc -> x ++ str ++ acc) (thr Zero) [ (thr One), (thr Two) ]

concatMatrixWith :: String -> String -> Matrix String -> String
concatMatrixWith rowSep colSep (MkMatrix xss) =
  foldl (\x acc -> x ++ rowSep ++ acc)
  (concatThriceWith colSep (xss Zero))
  [ (concatThriceWith colSep (xss One)), (concatThriceWith colSep (xss Two)) ]

showMatrixComposition :: (a -> String) -> Matrix a -> String
showMatrixComposition = error "not implemented"

instance Show a => Show (Matrix a) where
  show = showMatrix show

{-
type GenericMatrix =

foldGenericMatrix ::
mapGenericMatrix ::
multGenericMatrix ::
-}
